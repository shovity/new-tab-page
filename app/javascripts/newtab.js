// REQUEST LIST
const GET_NOTES     = 'GET_NOTES'
const POST_NOTES    = 'POST_NOTES'
const GET_BOOKMARK  = 'GET_BOOKMARK'
const GET_MOSTSITE  = 'GET_MOSTSITE'
const ARE_YOU_READY = 'ARE_YOU_READY'

// init config
const debug           = true
const minWallpaper    = false
const wallpaperRandom = true
const showMostSite    = true

// init varible
const wW     = window.document.documentElement.clientWidth
const wH     = window.document.documentElement.clientHeight
const images = window.imageIndex.map(e => `images/backgrounds/${e}`)

const codeTables = [
  { code: /\[date\]/, value: new Date().toLocaleDateString() },
  { code: /\[time\]/, value: new Date().toLocaleTimeString() },
]

// create port to connect to background scripts (when boot chrome)
let port = chrome.runtime.connect({ name: "pip" })

// delay pooling request on boot system
const requestDelay = 1000

// define interval request
let requsetInterval = null
let backgroundNotReady = true

// note state
window.notes = []

if (!debug) console.log = () => 'debug disabled'

// random wallpaper
if (wallpaperRandom) {
  const i = Math.floor(Math.random() * images.length)
  wall.style.backgroundImage = `url(${images[i]})`
  wallGhost.style.backgroundImage = `url(${images[i]})`
}

/**
 * Config
 */

const config = {}

config.set = (name, value) => {
  if (typeof name !== 'string' || typeof value !== 'string') return console.error('config key and value must ne string')
  window.localStorage.setItem(name, value)
}

config.get = (name) => {
  return window.localStorage.getItem(name)
}

/**
 * Bookmark bar
 * ============
 */
const bookmark = {
  htmlBookmarkBar: window.bookmarkBar,
  htmlMenu: window.bookmarkContextMenu,
}

/**
 * Create bookmark item from bookmark nodes
 * @param  {Object} node
 * @return {string}      HTML generated by bookmark node
 */
bookmark.createItem = (node) => {
  const { url, title, children } = node
  if (children) {
    setTimeout(() => bookmark.render(node))
    return ''
  }

  return `
  <a class="item" href="${url}">
    <img src="chrome://favicon/${url}">
    <div class="title">${title}</div>
  </a>`
}

/**
 * Create a parent of bookmark, this is a group of bookmark items
 * @param  {Object} node
 * @return {string}      HTML generated by bookmark nodes
 */
bookmark.createParent = (node) => {
  const label = node.title
  const nodes = node.children
  const childs = nodes.map(node => bookmark.createItem(node)).join('')
  const parentId = `${label}-${node.parentId || 'root'}`
  const status = config.get(`bookmark:parent:${parentId}`) || 'open'

  return `
  <div class="parent ${status}">
    <div class="parent-header" data-parent-id="${parentId}">
      <span class="icon icon-folder"></span>
      <div class="label">${label}</div>
    </div>
    <div class="stopgrap"></div>

    <div class="parent-childs">
      ${childs}
    </div>
  </div>`
}

/**
 * Render bookmark from bookmark node
 * @param  {Object}  node
 * @param  {Boolean} [clear=false] clean bookmark bar before render
 */
bookmark.render = (node, clear=false) => {
  if (clear) bookmark.htmlBookmarkBar.innerHTML = ''
  bookmark.htmlBookmarkBar.innerHTML += bookmark.createParent(node)
}

/**
 * ToggleOpenParent
 * @param  {string} parentId
 */
bookmark.toggleOpenParent = (parentId) => {
  // set config
  const key = `bookmark:parent:${parentId}`
  const open = config.get(key) === 'close'? 'open' : 'close'
  config.set(key, open)

  // change style bookmark parent
  document.querySelector(`[data-parent-id="${parentId}"]`).parentNode.className = `parent ${open}`
}

{
  /**
   * BOOKMARK BAR BEHAVIOR
   */
  bookmark.htmlBookmarkBar.addEventListener('click', event => {
    const { target } = event

    // detect toggle parent
    const parentId = target.getAttribute('data-parent-id') || target.parentNode.getAttribute('data-parent-id')
    if (parentId) bookmark.toggleOpenParent(parentId)
  })
}

/**
 * Noter
 * =====
 */
const pushState = () => {
  // console.log('push state: ', notes)
  port.postMessage({ request: POST_NOTES, data: notes })
}

const genUniqueNoteId = () => {
  return Date.now()
}

const createNoteObject = (msg, x, y, w = 300, h = 100, node=localStorage.node) => {
  // random position
  if (!x || !y) {
    x = Math.floor(Math.random() * (wW - 500))
    y = Math.floor(Math.random() * (wH - 250))
  }

  return { msg, x, y, w, h, node}
}

const createNoteHtmlElement = (id, msg, x, y, w, h) => {
  // console.log('render note id: ', id)
  return `
    <div id="noteid-${id}" class="note" style="transform: translate(${x}px, ${y}px)">
      <div class="box">
        <div class="note-controls" move-noteid="${id}">
          <div class="note-remove" remove-noteid="${id}">&times;</div>
        </div>
        <div class="rain-bow"><div></div><div></div><div></div></div>
        <textarea
          autocomplete="off"
          autocorrect="off"
          autocapitalize="off"
          spellcheck="false"
          placeholder="new note"
          editor-noteid="${id}"
          style="width:${w}px;height:${h-20}px;">${msg}</textarea>
      </div>
    </div>
  `
}

const addNote = (note) => {
  let { id, msg, x, y, w, h, node } = note

  // New note don't have a id
  // push it to state
  if (id === undefined) {
    const id = genUniqueNoteId()
    notes.push({ id, msg, x, y, w, h, node })
  }

  // console.log(`add note ${id} = ${msg}`)

  // render html
  noteBox.innerHTML += createNoteHtmlElement(id, msg, x, y, w, h)
}

const renderNotes = (notes, clear=true, node=+localStorage.node) => {

  // clear before render
  if (clear) noteBox.innerHTML = ''

  // loop adding
  notes.filter(note => {
    console.log(node, note.node);
    
    return node === undefined || node === +note.node 
  }).forEach(note => {
    addNote(note)
  })
}

const checkAndReplaceCode = (target) => {
  const string = target.value

  codeTables.forEach(code => {
    const result = string.match(code.code)
    if (result) {
      const data = result[1]
      target.value = string.replace(code.code, code.value.replace('$', data))
    }
  })
}

{
  // NOTES BEHAVIOR

  // listen remove note
  window.noteBox.addEventListener('click', event => {
    const { target } = event
    if (target.getAttribute('remove-noteid') !== null) {
      const noteId = +target.getAttribute('remove-noteid')
      const noteIndex = notes.findIndex((note) => note.id == noteId)

      if (noteIndex !== -1) notes.splice(noteIndex, 1)
      renderNotes(notes)
      // push state when remove a note
      pushState()
    }
  })

  // Handle move
  let resizeId = false
  let moveId = false
  let fixX = 0
  let fixY = 0

  window.noteBox.addEventListener('mousedown', event => {
    const { target } = event
    // console.log('mouse down on: ', target)

    // detect resize
    if (target.getAttribute('editor-noteid') !== null) {
      const cx = event.clientX
      const cy = event.clientY
      const noteId = +target.getAttribute('editor-noteid')
      const noteIndex = notes.findIndex((note) => note.id == noteId)
      const note = notes[noteIndex]

      // detect mouse down over resize btn
      if (note.x + note.w - cx < 15 && note.y + note.h - cy < 15) {
        resizeId = noteId
        // console.log('start resize, resizeId ', resizeId)
      }
    }

    if (target.getAttribute('move-noteid') !== null) {
      const noteId = +target.getAttribute('move-noteid')
      const noteIndex = notes.findIndex((note) => note.id == noteId)

      // fix position mouse vs note
      fixX = event.clientX - notes[noteIndex].x
      fixY = event.clientY - notes[noteIndex].y

      // start move handle
      moveId = noteId
    }
  })

  window.addEventListener('mousemove', event => {
    if (moveId === false) return

    event.preventDefault()
    const x = event.clientX - fixX
    const y = event.clientY - fixY

    if (window[`noteid-${moveId}`]) window[`noteid-${moveId}`].style.transform = `translate(${x}px, ${y}px)`
  })

  window.addEventListener('mouseup', event => {
    if (moveId !== false) {
      // update state
      const x = event.clientX - fixX
      const y = event.clientY - fixY
      const noteIndex = notes.findIndex((note) => note.id == moveId)

      if (noteIndex !== -1) {
        notes[noteIndex].x = x
        notes[noteIndex].y = y
      }

      // end move handle
      moveId = false

      // push state when done move a note
      pushState()

    } else if (resizeId !== false) {
      const { target } = event
      const noteIndex = notes.findIndex((note) => note.id == resizeId)
      const w = window['noteid-' + resizeId].offsetWidth
      const h = window['noteid-' + resizeId].offsetHeight

      if (noteIndex !== -1) {
        notes[noteIndex].w = w
        notes[noteIndex].h = h
      }

      // end resize handle
      resizeId = false

      // push state when done move a note
      pushState()
    }


  })

  // Handle edit notes
  // keyup only when focus textarea
  window.noteBox.addEventListener('keyup', (event) => {
    const { target } = event
    if (target.getAttribute('editor-noteid') !== null) {
      const noteId = +target.getAttribute('editor-noteid')
      const noteIndex = notes.findIndex((note) => note.id == noteId)

      // handle note code
      if (event.key === ']') checkAndReplaceCode(target)

      notes[noteIndex].msg = target.value
      // push state when done press a key if focus textarea
      pushState()
    }
  })

  // listen add note
  window.btnAddNote.addEventListener('click', () => {
    addNote(createNoteObject(''))
    // push state when add a note
    pushState()
    renderNotes(notes)
  })

  // listen switch node
  window.btnSwitchNode.addEventListener('click', () => {
    currentNode = +localStorage.node
    if (currentNode > 2) {
      currentNode = 0
    } else {
      currentNode++
    }

    window.btnSwitchNode.innerHTML = currentNode

    localStorage.node = currentNode
    renderNotes(window.notes)
  })
}

{
  let waveInterval = null
  let ghostTimeout = null
  let ctrlPress = false

  const addWave = (x, y) => {

    waveClickBox.innerHTML =
    `<div class="wave active" style="transform: translate(${x}px, ${y}px)">
      <div></div>
      <div></div>
      <div></div>
    </div>`
  }

  window.addEventListener('mousedown', (event) => {
    const x = event.clientX
    const y = event.clientY
    addWave(x, y)
    
    if (ctrlPress) {
      clearInterval(waveInterval)
      interval = setInterval(() => {
        addWave(x, y)
      }, 1900)
    } else {
      clearInterval(waveInterval)
    }
  })

  window.addEventListener('keydown', dEvent => {
    if (dEvent.keyCode === 13) {
      ctrlPress = true
    }

    if (dEvent.keyCode === 32 && !ghostTimeout) {
      wallGhost.className = 'ghost'
      ghostTimeout = setTimeout(() => {
        wallGhost.className = ''
        ghostTimeout = null
      }, 1000)
    }
  })

  window.addEventListener('keyup', dEvent => {
    ctrlPress = false
  })
}

// context menu
const contextMenu = {
  htmlMenu: window.contextMenu,
  isOpen: false
}

contextMenu.open = (x, y, h) => {
  const px = (x > wW - 200)? wW - 200 : x
  const py = (y > wH - 180)? wH - 180 : y+20

  contextMenu.isOpen = true

  contextMenu.htmlMenu.innerHTML =
  `<div style='transform: translate(${px}px, ${py}px)'>
    <div class="cm-i" cmd="kill them">click</div>
  </div>`
}

contextMenu.close = () => {
  contextMenu.isOpen = false
  contextMenu.htmlMenu.innerHTML = ''
}

// handle open menu
window.addEventListener('contextmenu', (event) => {
  return // Building...
  if (contextMenu.isOpen) {
    contextMenu.close()
  } else {
    contextMenu.open(event.clientX, event.clientY)
  }
  event.preventDefault()
})

// handle close and actions menu
window.addEventListener('click', (event) => {
  // pass when menu is closed
  if (!contextMenu.isOpen) return

  const { target } = event
  if (target.className !== 'cm-i') {
    contextMenu.close()
    event.preventDefault()
  } else {
    // console.log('hang ve: ' + target.getAttribute("cmd"))
    contextMenu.close()
  }
})

/**
 * Long connect "pip"
 * Main way to pass data
 */

port.onMessage.addListener(({ request, data, err }) => {

  if (err) return console.log(err)

  // console.log({ request })

  switch (request) {
    case ARE_YOU_READY:
      if (data) {
        port.postMessage({ request: GET_MOSTSITE })
        port.postMessage({ request: GET_NOTES })
        backgroundNotReady = false
        // console.log('background is ready, request interval cleared')
        clearInterval(requsetInterval)
        requsetInterval = null
      } else {
        // out of case
      }
      break

    case GET_BOOKMARK:
      bookmark.render(data[0].children[0])
      break

    case GET_MOSTSITE:
      bookmark.render({ children: data, title: 'Most visited' }, true)
      // request get bookmark when received most site visited
      port.postMessage({ request: GET_BOOKMARK })
      break

    case GET_NOTES:
      notes = data.notes || []
      // console.log('received notes form backgroud: ', notes)
      renderNotes(notes)
      break

    default:
      // out of service
      console.log('Revice response not match')
  }
})

// render value btn node
window.btnSwitchNode.innerHTML = localStorage.node

// request note to background scripts .,-+)
port.postMessage({ request: ARE_YOU_READY })
if (requsetInterval === null && backgroundNotReady) requsetInterval = setInterval(() => {
  location.reload()
}, requestDelay)
